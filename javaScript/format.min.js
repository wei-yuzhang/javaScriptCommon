/*********************************** AJAX 封装 ***********************************/

/**
 * @ 原生异步请求的封装
 * @ options.url: 地址
 * @ options.type: 请求方式
 * @ options.async: 同步：false，异步：true
 * @ options.contentType: 数据格式
 * @ options.data: 参数
 * @ options.success: function (data) {}返回请求数据
**/

function ajax (options) {
  // console.log(options);
  var xhr = null;
  var params = formsParams(options.data);

  //创建对象
  if (window.XMLHttpRequest) {
    xhr = new XMLHttpRequest()
  } else {
    xhr = new ActiveXObject('Microsoft.XMLHTTP');
  }

  // 请求的接口地址以及请求方式
  var type = options.type.toLowerCase()

  // 用于清除缓存
  var random = Math.random();

  // 异步还是同步
  options.async = options.async || true;

  // 判断请求方式
  if (type === 'get') {
    xhr.open(type, options.url + '?' + params + '&' + random, options.async);
    xhr.setRequestHeader('Content-type', 'application/json' || options.contentType);
    xhr.send(null);
  } else if (type === 'post') {
    params = JSON.stringify(options.data);
    xhr.open(type, options.url, options.async);
    xhr.setRequestHeader('Content-type', options.contentType || 'application/x-www-form-urlencoded');
    xhr.send(params);
  }

  // 请求成功后的方法
  xhr.onreadystatechange = function () {
    if (xhr.readyState === 4 && xhr.status === 200) {
      // console.log(xhr.responseText);
      options.success(JSON.parse(xhr.responseText))
    } else {
      alert('获取数据错误！错误代号：' + xhr.status + '，错误信息：' + xhr.statusText);
    }
  }

    // 参数拼接
    function formsParams (data) {
      var arr = [];
      for (var prop in data) {
        if (data.hasOwnProperty(prop)) {
          arr.push(prop + '=' + data[prop]);
        }
      }
      return arr.join('&');
    }
  }

/*********************** 显示 hide()与隐藏 show() 的方法 ***********************/

// 隐藏 hide() 方法
Object.prototype.hide = function () {
  this.style.display = 'none';
  return this;
}

// 显示 show() 方法
Object.prototype.show = function () {
  this.style.display = 'block';
  return this;
}

/************* 向下滑动显示 sliderDown() | 向上滑动隐藏 sliderUp() *************/

// 向下滑动显示 sliderDown() 方法
Object.prototype.sliderDown = function () {
  this.style.display = 'block';
  if (this.clientHeight < this.scrollHeight) {
    this.style.height = 10 + this.clientHeight + 'px';
    var _this = this;
    setTimeout(function () {
      _this.slideDown()
    }, 10)
  } else {
    this.style.height = this.scrollHeight + 'px';
  }
}

// 向上滑动隐藏 sliderUp() 方法
Object.prototype.sliderUp = function () {
  if (this.clientHeight > 0) {
    this.style.height = this.clientHeight - 10 + 'px';
    var _this = this;
    setTimeout(function () {
      _this.sliderUp()
    }, 10)
  } else {
    this.style.height = 0;
    this.style.display = 'none';
  }
}

/********************************* 捕获/设置属性 *********************************/

// val()--获取输入框的内容或者设置内容
Object.prototype.val = function () {
  if (arguments.length === 0) {
    return this.value;
  } else if (arguments.length === 1) {
    this.value = arguments[0];
    return this;
  }
}

// html()--获取或者设置被选元素的内容
Object.prototype.html = function () {
  if (arguments.length === 0) {
    return this.innerHTML;
  } else if (arguments.length === 1) {
    this.innerHTML = arguments[0];
    return this;
  }
}

/**************************** 设置样式 css() 的方法 ****************************/

// 设置样式 css() 方法（可以设置单个也可以设置多个）如果存在例如 text-align 属性，需要写成 textAlign
Object.prototype.css = function (newCssName) {
  console.log(arguments);
  if (arguments.length === 1) { // 返回对应的 css 属性值
    if (typeof(arguments[0]) === 'string') {
      return eval('this.style.' + arguments[0]);
    } else {
      for (var i in arguments[0]) {
        if (arguments[0].hasOwnProperty(i)) {  // 建议加上判断,如果没有扩展对象属性可以不加
          eval("this.style." + i + "='" + arguments[0][i] + "'");
        }
      }
      return this;
    }
  } else {
    eval("this.style." + arguments[0] + "='" + arguments[1] + "'");
    return this;
  }
}

/********************************** 添加元素 **********************************/

// 在被选元素结尾（内部）添加元素 append() 方法
Object.prototype.appendElem = function (newElem) {
  this.innerHTML += newElem;
  return this;
}

// 在被选元素开头（内部）添加原色 prepend() 方法
Object.prototype.prependElem = function (newElem) {
  console.log(arguments);
  this.innerHTML = arguments[0] + this.innerHTML;
  return this;
}

// 在被选元素结尾（外部）添加元素 afterElem() 方法
Object.prototype.afterElem = function (newElem) {
  this.outerHTML += arguments[0];
  return this;
}

// 在被选元素开头（外部）添加元素 beforeElem() 方法
Object.prototype.beforeElem = function (newElem) {
  console.log(this.outerHTML);
  console.log(arguments[0] + this.outerHTML);
  this.outerHTML = arguments[0] + this.outerHTML;
  return this;
}

/******************************** 删除/替换元素 ********************************/

// empty() 清空元素
Object.prototype.empty = function () {
  this.innerHTML = '';
  return this;
}

// replaceWith() 替换元素
Object.replaceWith = function (newElem) {
  this.outHTML = arguments[0];
  return this;
}

/*********************************** 选择器 ***********************************/

// id 或 class 选择器 $('elem')
function $(strExpr) {
  var idExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/;
  var classExpr = /^(?:\s*(<[\w\W]+>)[^>]*|.([\w-]*))$/;
  if (idExpr.test(strExpr)) {
    var idMatch = idExpr.exec(strExpr);
    return document.getElementById(idMatch[2]);
  } else if (classExpr.test(strExpr)) {
    var classMatch = classExpr.exec(strExpr);
    var allElement = document.getElementsByTagName('*');
    var ClassMatch = [];
    for (var i = 0, l = allElement.length; i < l; i++) {
      if (allElement[i].className.match( new RegExp( '(\\s|^)' + classMatch[2] + '(\\s|$)'))) {
        ClassMatch.push(allElement[i]);
      }
    }
    return ClassMatch;
  }
}

/*********************************** DOM 遍历 ***********************************/

// siblings() 获取集合中匹配元素的同胞，获取的结果需要 forEach 使用
Object.prototype.siblings = function () {
  var child = this.parentNode.children;
  var eleMatch = [];
  for (var i = 0; i < child.length; i++) {
    if (child[i] != this) {
      eleMatch.push(child[i]);
    }
  }
  return eleMatch;
}

// userChildren 被选元素的所有直接子元素，获取的结果需要 forEach 使用
Object.prototype.userChildren = function () {
  var child = this.childNodes;
  var eleMatch = [];
  for (var i = 0; i < child.length; i++) {
    eleMatch.push(child[i]);
  }
  return eleMatch;
}

// parent 返回被选元素的直接父元素
Object.prototype.parent = function () {
  return this.parentNode;
}

// next()
Object.prototype.next = function () {
  return this.nextElementSibling;
}

// prev()
Object.prototype.prev = function () {
  return this.previousElementSibling;
}

/********************************* 防止重复点击 *********************************/

// 防止重复点击的方法：buttonElem：按钮的 id
var clickCount = 0; // 全局定义的点击次数
function preventReClick (buttonElem) {
  if (clickCount === 0) {

    // 点击次数加一
    clickCount++;

    // 按钮置灰禁用
    buttonElem.setAttribute('disabled', true);

    // 三秒后按钮恢复可用
    setTimeout(function () {
      clickCount = 0 ;
      buttonElem.removeAttribute ('disabled');
    }, 3000);
  }
}

/********************************* 防抖和节流 *********************************/

/**
 * @ 防抖函数：多次触发事件后，事件处理函数只执行一次，并且是在触发操作结束时执行。
 * @ param method 事件触发的操作
 * @ param delay 多少毫秒内连续触发事件，不会执行
 * @ returns {Function}
 */
function debounce (method, delay) {
  console.log(arguments);
  var timer = null;
  return function () {
    var self = this,
    args = arguments;
    if (timer) {
      clearTimeout(timer)
    }
    timer = setTimeout(function () {
      timer = null
      method.apply(self, args);
    }, delay);
  }
}

/**
 * 节流函数：触发函数事件后，短时间间隔内无法连续调用，只有上一次函数执行后，过了规定的时间间隔，才能进行下一次的函数调用。
 * @param method 事件触发的操作
 * @param mustRunDelay 间隔多少毫秒需要触发一次事件
 */
function throttle (method, mustRunDelay) {
  let timer,
      args = arguments,
      start;
  return function loop() {
    let self = this;

    // 获取当前时间
    let now = Date.now();

    // 判断时间差
    if (!start) {
      start = now;
    }
    if (timer) {
      clearTimeout(timer);
    }
    if (now - start >= mustRunDelay) {
      method.apply(self, args);
      start = now;
    } else {
      timer = setTimeout(function () {
        loop.apply(self, args);
      }, 50);
    }
  }
}

/*********************************** 鼠标事件 ***********************************/

var flag = false;
var mouseDownX;
var mouseDownY;
var mouseMoveX;
var mouseMoveY;
var moveDistanceX = 0;
var moveDistanceY = 0;

// 鼠标按下的方法
function mouseDown (e) {
  // 鼠标按下时的所在的 X,Y 坐标
  mouseDownX = e.pageX;
  mouseDownY = e.pageY;

  // 表示鼠标已经按下
  flag = true;

  // console.log('鼠标按下的位置：' + mouseDownX, mouseDownY);
}

// 鼠标移动的方法
document.onmousemove = function (e) {
  // 确保鼠标已经按下
  if (flag) {
    mouseMoveX = e.pageX;
    mouseMoveY = e.pageY;

    // console.log('鼠标移动的位置：' + mouseMoveX, mouseMoveY);
    moveDistanceX += (parseInt(mouseMoveX) - parseInt(mouseDownX)) / 50;
    moveDistanceY += (parseInt(mouseDownY) - parseInt(mouseMoveY)) / 50;

    // console.log('鼠标移动的距离：' + moveDistanceX, moveDistanceY);
  }
}

// 鼠标松开的方法
document.onmouseup = function () {
  // 标识已经松开鼠标
  flag = false;
}

// 判断鼠标滚轮滚动的方向
if (window.addEventListener && false) { // 火狐浏览器
  window.addEventListener('DOMMouseScroll', throttle(wheel, 1000), false);
  window.onmousewheel = document.onmousewheel = debounce(wheel, 1000);
}

// 统一处理滚轮滚动事件
function wheel (event) {
  var delta = 0;
  if (!event) {
    event = window.event;
  }
  // IE、chrome浏览器使用的是wheelDelta，并且值为“正负120”
  if (event.wheelDelta) {
    delta = event.wheelDelta / 120;
    // 因为IE、chrome等向下滚动是负值，FF是正值，为了处理一致性，在此取反处理
    if (window.opera) {
      delta = -delta;
    }
  } else if (event.detail) { // FF浏览器使用的是detail,其值为“正负3”
    delta = -event.detail/3;
  }
  if (delta) {
    handle(delta);
  }
}

// 上下滚动时的具体处理函数
function handle (delta) {
  if (delta < 0) { // 向下滚动
    console.log('向下滚动');
  }else{ // 向上滚动
    console.log('向上滚动');
  }
}
